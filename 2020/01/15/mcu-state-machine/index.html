<html>
<head><meta name="generator" content="Hexo 3.9.0">
	
	<title>基于baremetal的状态机设计</title>
	<meta name="keywords" content="howar.cn">

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css">
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3">
    
    
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-159646423-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>


<h2 class="title">基于baremetal的状态机设计</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2020年1月15日




 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#状态机设计"><span class="toc-text">状态机设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#状态"><span class="toc-text">状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件"><span class="toc-text">事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态机"><span class="toc-text">状态机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建状态机"><span class="toc-text">创建状态机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#添加状态"><span class="toc-text">添加状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#状态跳转"><span class="toc-text">状态跳转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调度器"><span class="toc-text">调度器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>单片机程序开发通常直接基于baremetal，或者使用较为简单的RTOS，虽然单片机开发程序相对来说较为简单，但同时也少了一些辅助软件系统设计的工具，<strong><em>一不小心</em></strong>就使得代码看起来杂乱无章，虽然功能都能实现，但对后期维护通常都是一种灾难。这篇blog结合实际工作中的总结，试图给出一种基于baremetal（基于RTOS/Linux当然也可以用）的状态机设计，使代码开发和维护都变得简单，也使代码更优雅。</p>
<h2 id="状态机设计"><a href="#状态机设计" class="headerlink" title="状态机设计"></a>状态机设计</h2><p>本状态机设计方案中，共有4个元素：</p>
<ul>
<li>状态</li>
<li>事件</li>
<li>状态机</li>
<li>调度器</li>
</ul>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>首先，给出状态的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">state</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> event;  <span class="comment">/* 触发该状态流转的事件，下面会进行介绍 */</span></span><br><span class="line">    <span class="keyword">state_handle_func_t</span> handle;  <span class="comment">/* 该状态的动作函数，即该状态被上述事件触发后执行该函数 */</span></span><br><span class="line">    <span class="keyword">int16_t</span> success_action;  <span class="comment">/* 上述动作函数执行成功后，该状态的跳转动作（通常为跳转到下一个状态） */</span></span><br><span class="line">    <span class="keyword">int16_t</span> wait_action;  <span class="comment">/* 上述动作函数执行后需等待，该状态的跳转动作（通常为仍然执行该状态） */</span></span><br><span class="line">    <span class="keyword">int16_t</span> fail_action;  <span class="comment">/* 上述动作函数执行失败后，该状态的跳转动作（通常为终止该状态机） */</span></span><br><span class="line">&#125; <span class="keyword">state_t</span>;</span><br></pre></td></tr></table></figure>

<p>将上述多个状态放入状态机中，即可实现包含若干个状态的状态机。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>状态机中状态在两种情况下可进行流转：周期性的调度器；特定事件的发生。这两种情况都离不开事件。在本设计中，定义了以下事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_EVENT_ALL     (0x00)    <span class="comment">/* 该事件通常保留 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_EVENT_MAIN    (0x01)    <span class="comment">/* 周期性调度器会使用该事件进行状态的执行和跳转 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_EVENT_TIMEOUT (0x02)    <span class="comment">/* 周期性调度器会使用该事件触发超时状态的执行 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_EVENT_TIMER   (0x04)    <span class="comment">/* 周期性调度器会使用该事件触发状态周期性timer函数的执行 */</span></span></span><br></pre></td></tr></table></figure>

<p>当然实际工程中还可以添加其他事件，比如某状态是传感器数据触发的，那么可以添加如下状态（下文会介绍具体如何使用）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_EVENT_SENSOR  (0x08)</span></span><br></pre></td></tr></table></figure>

<h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>同样，首先看看状态机定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">state_machine</span> &#123;</span></span><br><span class="line">    <span class="keyword">state_machine_timer_handle_func_t</span> timer_handle;  <span class="comment">/* 若不为NULL，则会被定时性调用 */</span></span><br><span class="line">    <span class="keyword">state_machine_callback_t</span> callback;  <span class="comment">/* 若不为NULL，则会在该状态机结束时调用 */</span></span><br><span class="line">    <span class="keyword">int</span> index;  <span class="comment">/* 当前状态索引 */</span></span><br><span class="line">    <span class="keyword">int</span> size;  <span class="comment">/* 该状态机所包含的状态个数 */</span></span><br><span class="line">	<span class="keyword">int</span> canceled;  <span class="comment">/* 该状态机是否被取消 */</span></span><br><span class="line">    <span class="keyword">state_t</span> states[<span class="number">1</span>];  <span class="comment">/* 该状态机所包含的状态，这里定义为长度为1的数组只是编程技巧，实际可包含若干个状态 */</span></span><br><span class="line">&#125; <span class="keyword">state_machine_t</span>;</span><br></pre></td></tr></table></figure>

<p>对于状态机而言，最重要的是：</p>
<ul>
<li>创建状态机</li>
<li>添加状态</li>
<li>状态跳转</li>
</ul>
<p>下面一一分析。</p>
<h4 id="创建状态机"><a href="#创建状态机" class="headerlink" title="创建状态机"></a>创建状态机</h4><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">state_machine_t</span>* state_machine_create(</span><br><span class="line">    <span class="keyword">uint16_t</span> state_count, <span class="keyword">uint16_t</span> context_size, <span class="keyword">void</span>** context) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="keyword">sizeof</span>(<span class="keyword">state_machine_t</span>) + <span class="keyword">sizeof</span>(<span class="keyword">state_t</span>) * (state_count - <span class="number">1</span>) + context_size;</span><br><span class="line">    <span class="keyword">state_machine_t</span>* sm = (<span class="keyword">state_machine_t</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">memset</span>(sm, <span class="number">0</span>, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (context) &#123;</span><br><span class="line">        *context = (<span class="keyword">uint8_t</span>*)sm + size - context_size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，创建状态机使用到了动态内存分配，所以在状态机结束时需要释放对应内存。在这个接口设计中，总共三个参数：</p>
<ul>
<li>state_count: 这个很好理解，就是状态的个数</li>
<li>context_size: 为每个状态机申请了一段内存，里面存放该状态机运行的上下文context，其里面的内容可以自定义。该参数就是context长度</li>
<li>context: 指向该上下文内存首地址的指针<h4 id="添加状态"><a href="#添加状态" class="headerlink" title="添加状态"></a>添加状态</h4>代码如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">state_machine_add</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">state_machine_t</span>* state_machine,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> event, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">state_handle_func_t</span> handle, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int16_t</span> success_action,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int16_t</span> wait_action,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int16_t</span> fail_action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">state_t</span>* state = &amp;state_machine-&gt;states[state_machine-&gt;size++];</span><br><span class="line">    state-&gt;event = event;</span><br><span class="line">    state-&gt;handle = handle;</span><br><span class="line">    state-&gt;success_action = success_action;</span><br><span class="line">    state-&gt;wait_action = wait_action;</span><br><span class="line">    state-&gt;fail_action = fail_action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>该函数比较简单，不作过多解释。实际工程中可能会大量调用该接口，用宏对其封装如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_EVENT2(e1, e2) \</span></span><br><span class="line">    (STATE_MACHINE_EVENT_##e1 | STATE_MACHINE_EVENT_##e2)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_EVENT3(e1, e2, e3) \</span></span><br><span class="line">	(STATE_MACHINE_EVENT2(e1, e2) | STATE_MACHINE_EVENT_##e3)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_ADD_EXT(sm, event, handle, success, wait, <span class="meta-keyword">error</span>) \</span></span><br><span class="line">    state_machine_add( \</span><br><span class="line">        sm,  \</span><br><span class="line">        STATE_MACHINE_##event, \</span><br><span class="line">        (<span class="keyword">state_handle_func_t</span>)handle, \</span><br><span class="line">        STATE_MACHINE_ACTION_##success, \</span><br><span class="line">        STATE_MACHINE_ACTION_##wait, \</span><br><span class="line">        STATE_MACHINE_ACTION_##error \</span><br><span class="line">    )</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_ADD(sm, event, handle, success, wait, <span class="meta-keyword">error</span>) \</span></span><br><span class="line">    state_machine_add( \</span><br><span class="line">        sm,  \</span><br><span class="line">        STATE_MACHINE_EVENT_##event, \</span><br><span class="line">        (<span class="keyword">state_handle_func_t</span>)handle, \</span><br><span class="line">        STATE_MACHINE_ACTION_##success, \</span><br><span class="line">        STATE_MACHINE_ACTION_##wait, \</span><br><span class="line">        STATE_MACHINE_ACTION_##error \</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>添加单事件触发的状态，使用<code>STATE_MACHINE_ADD</code>就可以了；有些状态的触发，可能多个事件中的任何一个就可以，那么可以使用<code>STATE_MACHINE_ADD_EXT</code>来添加：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 添加单事件触发示例 */</span></span><br><span class="line">STATE_MACHINE_ADD(sm, MAIN, state_handler, NEXT, NEXT, BREAK);</span><br><span class="line"><span class="comment">/* 添加多事件触发示例 */</span></span><br><span class="line">STATE_MACHINE_ADD_E(sm, EVENT2(MAIN, SENSOR), state_handler, NEXT, RETRY, BREAK);</span><br></pre></td></tr></table></figure>

<h4 id="状态跳转"><a href="#状态跳转" class="headerlink" title="状态跳转"></a>状态跳转</h4><p>状态跳转函数是状态机的核心，其代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">state_machine_run</span><span class="params">(<span class="keyword">int</span> event, <span class="keyword">void</span>* context, <span class="keyword">state_machine_t</span>* state_machine, <span class="keyword">void</span>* feedback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state_machine-&gt;canceled || (state_machine-&gt;index &gt;= state_machine-&gt;size)) &#123;</span><br><span class="line">        <span class="keyword">return</span> state_machine-&gt;callback(state_machine, <span class="number">0</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">state_t</span>* state = &amp;state_machine-&gt;states[state_machine-&gt;index];    </span><br><span class="line">    <span class="keyword">switch</span> (event) &#123;</span><br><span class="line">        <span class="keyword">case</span> STATE_MACHINE_EVENT_SENSOR:</span><br><span class="line">        <span class="keyword">case</span> STATE_MACHINE_EVENT_MAIN: &#123;</span><br><span class="line">            <span class="keyword">if</span> (state-&gt;event != <span class="number">0</span> &amp;&amp; (state-&gt;event &amp; event) != event) &#123;</span><br><span class="line">                <span class="keyword">return</span> SCHEDULE_CONTINUE;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">/* Run current state handle function */</span></span><br><span class="line">            <span class="keyword">int16_t</span> action = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> ret = state-&gt;handle(context, feedback);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* Return code convert to state machine action */</span></span><br><span class="line">            <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">                <span class="keyword">case</span> STATE_MACHINE_OK:</span><br><span class="line">                    action = state-&gt;success_action;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> STATE_MACHINE_WAIT:</span><br><span class="line">                    action = state-&gt;wait_action;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> STATE_MACHINE_ERROR:</span><br><span class="line">                    action = state-&gt;fail_action;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    action = STATE_MACHINE_ACTION_BREAK;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* Handle status action */</span></span><br><span class="line">            <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">                <span class="keyword">case</span> STATE_MACHINE_ACTION_NEXT:                </span><br><span class="line">                    state_machine-&gt;index++;</span><br><span class="line">                <span class="keyword">case</span> STATE_MACHINE_ACTION_RETRY:</span><br><span class="line">                    <span class="keyword">return</span> SCHEDULE_CONTINUE;</span><br><span class="line">                <span class="keyword">case</span> STATE_MACHINE_ACTION_BREAK:</span><br><span class="line">                    <span class="keyword">return</span> state_machine-&gt;callback(state_machine, ret, context);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    state_machine-&gt;index += action;</span><br><span class="line">                    <span class="keyword">return</span> SCHEDULE_CONTINUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> STATE_MACHINE_EVENT_TIMER: &#123;</span><br><span class="line">            state_machine-&gt;timer_handle(context);</span><br><span class="line">            <span class="keyword">return</span> SCHEDULE_CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> STATE_MACHINE_EVENT_TIMEOUT: &#123;</span><br><span class="line">            <span class="keyword">return</span> state_machine-&gt;callback(</span><br><span class="line">				state_machine, STATE_MACHINE_TIMEOUT, context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> SCHEDULE_CONTINUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于该函数，重点作以下说明：</p>
<ul>
<li>该函数的返回值有两个：<code>SCHEDULE_CONTINUE</code>和<code>SCHEDULE_OK</code>，当返回<code>SCHEDULE_OK</code>时表明这个状态机已经执行完毕</li>
<li>状态的跳转不是仅仅可以顺序向下跳转，也可以往回跳，也可以跨状态跳转，只要在添加状态时使用合适的<code>action</code>参数即可，比如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_ACTION_NEXT  (0x7FF0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_ACTION_RETRY (0x7FF1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_ACTION_BREAK (0x7FF2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Forward</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_ACTION_FORWARD_1  (1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_ACTION_FORWARD_2  (2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_ACTION_FORWARD_3  (3)</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//Backward</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_ACTION_BACKWARD_1  (-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_ACTION_BACKWARD_2  (-2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_MACHINE_ACTION_BACKWARD_3  (-3)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p>既然叫调度器，那么它处理的便是任务；说是任务，但其实和传统意义上的操作系统的任务还是有点区别的，因为这里的任务主要是包含状态机及状态机相关数据的集合，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">schedule_task</span> &#123;</span></span><br><span class="line">    <span class="keyword">schedule_handle_func_t</span> handle;  <span class="comment">/* 任务（状态机）被调度到时执行的函数 */</span></span><br><span class="line">    <span class="keyword">void</span>* context;  <span class="comment">/* 任务（状态机）的上下文 */</span></span><br><span class="line">    <span class="keyword">void</span>* sm;  <span class="comment">/* 任务对应的状态机 */</span></span><br><span class="line">    <span class="keyword">void</span>* feedback;  <span class="comment">/* 任务的反馈输入（比如收到的传感器数据） */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> active_time;  <span class="comment">/* 任务（状态机）被激活的时间戳 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> timeout;  <span class="comment">/* 任务（状态机）超时时间 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> recently_wakeup_time;  <span class="comment">/* 任务（状态机）最近一次被调度的时间戳 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> timer;  <span class="comment">/* 任务（状态机）定时时间周期 */</span></span><br><span class="line">&#125; <span class="keyword">schedule_task_t</span>;</span><br></pre></td></tr></table></figure>

<p>其中<code>schedule_handle_func_t</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">schedule_handle_func_t</span>)</span><span class="params">(<span class="keyword">int</span> event, <span class="keyword">void</span>* context, <span class="keyword">void</span>* callback, <span class="keyword">void</span>* feedback)</span></span>;</span><br></pre></td></tr></table></figure>

<p>实际上对应这上文中的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">state_machine_run</span><span class="params">(<span class="keyword">int</span> event, <span class="keyword">void</span>* context, <span class="keyword">state_machine_t</span>* state_machine, <span class="keyword">void</span>* feedback)</span></span></span><br></pre></td></tr></table></figure>

<p>对于调度器而言，最重要的是提供两方面的能力：任务的添加、任务的调度执行。分别介绍如下：</p>
<ul>
<li>任务的添加</li>
</ul>
<p>首先，需要一个ring buffer来存储管理任务队列，其数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHEDULE_QUEUE_SIZE (5)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">schedule_task_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">schedule_task_t</span> task[SCHEDULE_QUEUE_SIZE];</span><br><span class="line">    <span class="keyword">uint32_t</span> first;</span><br><span class="line">    <span class="keyword">uint32_t</span> last;</span><br><span class="line">&#125; <span class="keyword">schedule_task_queue_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">schedule</span> &#123;</span></span><br><span class="line">    <span class="keyword">schedule_task_queue_t</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125; <span class="keyword">schedule_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">schedule_t</span> s_schedule;</span><br></pre></td></tr></table></figure>

<p>新的任务可以从头部，也可以从尾部添加进该任务队列。需要注意的是，对于一个任务队列而言，其任务执行是阻塞机制的，即只有队首的任务执行完（状态机的所有状态都执行完）之后，接下来的任务才会执行，这样可以把相关联的状态机放入同一个队列中。如果有需要，可以创建多个队列（即多个<code>schedule_t类型的变量</code>）。</p>
<p>介绍完上述背景后，就可以给出任务添加的核心接口了，即获取队列中相应的任务指针（获取到后，进行相应的赋值即可）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将任务放置到队首 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> schedule_task_t* <span class="title">schedule_task_queue_push_front</span><span class="params">(<span class="keyword">schedule_task_queue_t</span>* <span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> prev = (<span class="built_in">queue</span>-&gt;first + SCHEDULE_QUEUE_SIZE - <span class="number">1</span>) % SCHEDULE_QUEUE_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="built_in">queue</span>-&gt;last) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">schedule_task_t</span>* result = &amp;<span class="built_in">queue</span>-&gt;task[prev];</span><br><span class="line">    <span class="built_in">queue</span>-&gt;first = prev;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将任务放置到队尾 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> schedule_task_t* <span class="title">schedule_task_queue_push_back</span><span class="params">(<span class="keyword">schedule_task_queue_t</span>* <span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> next = (<span class="built_in">queue</span>-&gt;last + <span class="number">1</span>) % SCHEDULE_QUEUE_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="built_in">queue</span>-&gt;first) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">schedule_task_t</span>* result = &amp;<span class="built_in">queue</span>-&gt;task[<span class="built_in">queue</span>-&gt;last];</span><br><span class="line">    <span class="built_in">queue</span>-&gt;last = next;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>任务的调度执行</li>
</ul>
<p>任务的调度执行主要完成以下工作：</p>
<ol>
<li>总是执行处于队首的状态机任务，当队首状态机任务全部执行完毕后，负责将队首的位置移到下一个状态机任务；</li>
<li>检查当前队首状态机任务的周期性timer是否到达，若到达则执行相关函数；</li>
<li>检查当前队首状态机任务是否超时，若超时，则负责将队首的位置移到下一个状态机任务。</li>
</ol>
<p>对应的代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> schedule_task_t* <span class="title">schedule_task_queue_peek</span><span class="params">(<span class="keyword">schedule_task_queue_t</span>* <span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;first != <span class="built_in">queue</span>-&gt;last ? &amp;<span class="built_in">queue</span>-&gt;task[<span class="built_in">queue</span>-&gt;first] : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> schedule_task_t* <span class="title">schedule_task_queue_pop</span><span class="params">(<span class="keyword">schedule_task_queue_t</span>* <span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;first == <span class="built_in">queue</span>-&gt;last) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">schedule_task_t</span>* first = schedule_task_queue_peek(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;first = (<span class="built_in">queue</span>-&gt;first + <span class="number">1</span>) % SCHEDULE_QUEUE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_move_next</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">schedule_task_t</span>* task = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	schedule_task_queue_pop(&amp;s_schedule.<span class="built_in">queue</span>);</span><br><span class="line">			</span><br><span class="line">	<span class="keyword">if</span> ((task = schedule_task_queue_peek(&amp;s_schedule.<span class="built_in">queue</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		task-&gt;active_time = get_tick_msec(); <span class="comment">/* get_tick_msec()为获取当前系统时间戳接口，与具体平台相关 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule_handle</span><span class="params">(<span class="keyword">int</span> event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> now = get_tick_msec(); <span class="comment">/* get_tick_msec()为获取当前系统时间戳接口，与具体平台相关 */</span></span><br><span class="line">    <span class="keyword">schedule_task_t</span>* task = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Handle queue's task</span></span><br><span class="line">    <span class="keyword">while</span> ((task = schedule_task_queue_peek(&amp;s_schedule.<span class="built_in">queue</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((task-&gt;active_time + task-&gt;timeout) &lt;= now) &#123;</span><br><span class="line">            task-&gt;handle(STATE_MACHINE_EVENT_TIMEOUT, task-&gt;context, task-&gt;callback, <span class="literal">NULL</span>);</span><br><span class="line">            schedule_move_next();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//Check timer and wakeup handle function for timer event</span></span><br><span class="line">        <span class="keyword">if</span> ((task-&gt;timer &gt; <span class="number">0</span>) &amp;&amp; (now - task-&gt;recently_wakeup_time &gt;= task-&gt;timer)) &#123;</span><br><span class="line">            task-&gt;handle(STATE_MACHINE_EVENT_TIMER, task-&gt;context, task-&gt;callback, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">//Update wake up time</span></span><br><span class="line">            task-&gt;recently_wakeup_time = get_tick_msec();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (task-&gt;handle(event, task-&gt;context, task-&gt;callback, <span class="literal">NULL</span>) == SCHEDULE_OK) &#123;</span><br><span class="line">            schedule_move_next();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>schedule_handle</code>需要在主函数中周期性调用，且通常传入参数<code>STATE_MACHINE_EVENT_MAIN</code>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过对上述元素的实现，可以得到一个可用的（也算好用的），能在单片机系统（也可在RTOS/Linux上）运行的状态机。</p>


<!--<a href="http://www.howar.cn/2020/01/15/mcu-state-machine/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=&web_id=" language="JavaScript"></script>script>
</div>






</body>
</html>