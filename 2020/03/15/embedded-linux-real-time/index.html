<html>
<head><meta name="generator" content="Hexo 3.9.0">
	
	<title>Linux内核针对实时性的调优</title>
	<meta name="keywords" content="howar.cn">

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css">
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3">
    
    
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-159646423-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>


<h2 class="title">Linux内核针对实时性的调优</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2020年3月15日




 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是操作系统的实时性"><span class="toc-text">什么是操作系统的实时性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux为什么不是硬实时操作系统"><span class="toc-text">Linux为什么不是硬实时操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux在哪些时机不可调度"><span class="toc-text">Linux在哪些时机不可调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何改进Linux内核的实时性"><span class="toc-text">如何改进Linux内核的实时性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PREEMPT-RT补丁"><span class="toc-text">PREEMPT_RT补丁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PREEMPT-RT补丁原理"><span class="toc-text">PREEMPT_RT补丁原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于Raspberry-Pi-3B的PREEMPT-RT补丁效果测试"><span class="toc-text">基于Raspberry Pi 3B的PREEMPT_RT补丁效果测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#获取获取实时补丁的kernel源码"><span class="toc-text">获取获取实时补丁的kernel源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工具链相关配置"><span class="toc-text">工具链相关配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内核编译配置"><span class="toc-text">内核编译配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内核编译"><span class="toc-text">内核编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#新内核安装"><span class="toc-text">新内核安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实时性能测试"><span class="toc-text">实时性能测试</span></a></li></ol></li></ol></li></ol>
<h2 id="什么是操作系统的实时性"><a href="#什么是操作系统的实时性" class="headerlink" title="什么是操作系统的实时性"></a>什么是操作系统的实时性</h2><p>首先看看维基百科对实时操作系统的定义：</p>
<blockquote>
<p><strong>实时操作系统（Real-time operating system, RTOS）</strong>，又称即时操作系统，它会按照排序运行、管理系统资源，并为开发应用程序提供一致的基础。实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。</p>
</blockquote>
<p><strong>“实时性”</strong> 是实时操作系统最大的特性。</p>
<p>而维基百科对“实时性”的定义如下：</p>
<blockquote>
<p>实时运算（Real-time computing）是计算机科学中对受到“实时约束”的计算机硬件和计算机软件系统的研究，实时约束像是从事件发生到系统回应之间的最长时间限制。实时程序必须保证在严格的时间限制内响应。</p>
</blockquote>
<p>对于实时性理解的重点是，实时并不是意味着速度快，其关键在于保证完成时间，而不是原始速度。</p>
<p>而针对用户对超出时间限制所造成的影响的可接受程度，实时又可分为软实时和硬实时：</p>
<ul>
<li><p>软实时<br><br>软实时的特点是如果超过了时间限制后操作还没有完成的话，体验的质量就会下降，但不会带来致命后果。结果可能不尽如人意，并导致体验的质量有所下降，但这并不是灾难性的。</p>
</li>
<li><p>硬实时<br><br>硬实时的特点是错过时限会造成严重结果。在一个硬实时系统中，如果错过了时限，后果往往是灾难性的。当然，“灾难”是相对而言的。 </p>
</li>
</ul>
<h2 id="Linux为什么不是硬实时操作系统"><a href="#Linux为什么不是硬实时操作系统" class="headerlink" title="Linux为什么不是硬实时操作系统"></a>Linux为什么不是硬实时操作系统</h2><p>Linux系统一开始就被按照GPOS(通用操作系统)来设计的，它所追求的是尽量缩短系统的平均相应时间，提高吞吐量，达到更好的平均性能。在这个背景下，Linux无法达到强实时性的因素是多方面的，比如虚拟内存管理、共享资源互斥访问机制等等，但最重要的因素是进程调度以及内核抢占机制，这也是本文讨论的重点。</p>
<h3 id="Linux在哪些时机不可调度"><a href="#Linux在哪些时机不可调度" class="headerlink" title="Linux在哪些时机不可调度"></a>Linux在哪些时机不可调度</h3><p>想要搞清这个问题，首先需要介绍一下linux中的四类区间：</p>
<ol>
<li>中断</li>
<li>软中断</li>
<li>进程上下文中的spin_lock</li>
<li>进程上下文中的其他区域</li>
</ol>
<p>上述四类区间中，只有第四类区间支持抢占调度。当可以调度的事情发生在前3类区间中，即如果在这3类区间中唤醒了高优先级的可以抢占的task，实际上却不能抢占，直到这3类区间结束。</p>
<p>用一个例子说明如下：<br><img src="/images/embedded-linux-real-time/preemptive.png" width="703" height="512" align="center"></p>
<p>如上图所示：</p>
<ul>
<li>T0时刻<code>Normal task</code>因为<code>syscall</code>陷入内核</li>
<li>T1时刻<code>CPU</code>拿到<code>spin lock</code>，进入<code>Critical section</code></li>
<li>T2时刻系统产生中断<code>IRQ1</code>，进入<code>IRQ handler</code></li>
<li>T3时刻系统唤醒了高优先级的<code>RT task</code>，但由于此时系统处于不可调度区域，所以<code>RT task</code>无法立即运行</li>
<li>T4时刻<code>IRQ1</code>结束，但接着产生中断<code>IRQ2</code>，进入<code>IRQ handler</code></li>
<li>T5时刻，中断都结束，但<code>spin lock</code>仍然没有释放，系统仍然处于不可调度区域</li>
<li>T6时刻，<code>spin lock</code>释放，高优先级的<code>RT task</code>立马得到调度</li>
<li>T7时刻<code>RT task</code>运行结束，<code>Normal task</code>再一次被调度到</li>
<li>T8时刻从内核态返回</li>
</ul>
<p>从T1到T6，这个区间的时间是不可预测的，因此通用的Linux系统无法达到硬实时的标准。</p>
<h2 id="如何改进Linux内核的实时性"><a href="#如何改进Linux内核的实时性" class="headerlink" title="如何改进Linux内核的实时性"></a>如何改进Linux内核的实时性</h2><p>当前主要有两种方式对Linux内核的实时性进行优化：</p>
<ol>
<li>修改内核代码<br><br>通过打布丁的方式，对内核的进程调度、中断服务程序等代码进行修改与优化，提高系统的实时性能，并且保证了系统的通用性。当前社区的维护的，最出名的就是<code>PREEMPT_RT</code>布丁。</li>
<li>双内核法<br><br>通过在Linux内核与硬件中断之间增加一个可抢先的实时内核，把标准的Linux内核作为该实时内核的一个优先级最低的进程来调度，它可以被实时进程抢断，正常的Linux进程仍可以在Linux内核上运行，这样既可以使用标准分时操作系统即Linux的各种服务，又能提供低延时的实时环境。RT-Linux是采用双内核法改造Linux实时性的典型代表。</li>
</ol>
<p>本文主要讨论第一种方式的原理及效果。</p>
<h2 id="PREEMPT-RT补丁"><a href="#PREEMPT-RT补丁" class="headerlink" title="PREEMPT_RT补丁"></a>PREEMPT_RT补丁</h2><h3 id="PREEMPT-RT补丁原理"><a href="#PREEMPT-RT补丁原理" class="headerlink" title="PREEMPT_RT补丁原理"></a>PREEMPT_RT补丁原理</h3><p><code>PREEMPT_RT</code>补丁可以通过以下方面对kernel进行源码级的改造：</p>
<ul>
<li>spinlock迁移为可调度的mutex</li>
<li>中断线程化</li>
<li>软中断线程化</li>
</ul>
<p>从而将Linux内核中的1/2/3类区间都改造成4类区间，大大提高了系统的实时性。</p>
<h3 id="基于Raspberry-Pi-3B的PREEMPT-RT补丁效果测试"><a href="#基于Raspberry-Pi-3B的PREEMPT-RT补丁效果测试" class="headerlink" title="基于Raspberry Pi 3B的PREEMPT_RT补丁效果测试"></a>基于Raspberry Pi 3B的PREEMPT_RT补丁效果测试</h3><h4 id="获取获取实时补丁的kernel源码"><a href="#获取获取实时补丁的kernel源码" class="headerlink" title="获取获取实时补丁的kernel源码"></a>获取获取实时补丁的<code>kernel</code>源码</h4><p>现在直接可以在<code>github</code>上获取带有实时补丁的<code>kernel</code>源码，使用以下<code>git</code>指令(假设都在<code>~/raspberrypi-kernel$</code>目录下进行)：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/raspberrypi-kernel$ git clone https://github.com/raspberrypi/linux.git -b rpi-4.14.y-rt</span><br></pre></td></tr></table></figure>

<p>编译过程在ubuntu 14.04上，因此需要进行交叉编译，获取相应的交叉编译工具链如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/raspberrypi-kernel$ git clone https://github.com/raspberrypi/tools.git</span><br></pre></td></tr></table></figure>

<h4 id="工具链相关配置"><a href="#工具链相关配置" class="headerlink" title="工具链相关配置"></a>工具链相关配置</h4><p>可以执行以下命令，对交叉编译工具链进行相关配置(首先在<code>~/raspberrypi-kernel</code>目录下新建目录<code>rt-kernel</code>)：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/raspberrypi-kernel$ export ARCH=arm</span><br><span class="line">~/raspberrypi-kernel$ export CROSS_COMPILE=~/raspberrypi-kernel/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin/arm-linux-gnueabihf-</span><br><span class="line">~/raspberrypi-kernel$ export INSTALL_MOD_PATH=~/raspberrypi-kernel/rt-kernel</span><br><span class="line">~/raspberrypi-kernel$ export INSTALL_DTBS_PATH=~/raspberrypi-kernel/rt-kernel</span><br></pre></td></tr></table></figure>

<h4 id="内核编译配置"><a href="#内核编译配置" class="headerlink" title="内核编译配置"></a>内核编译配置</h4><p>使用以下指令可以对内核编译进行相关配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/raspberrypi-kernel$ export KERNEL=kernel7</span><br><span class="line">~/raspberrypi-kernel$ cd ~/raspberrypi-kernel/linux/</span><br><span class="line">~/raspberrypi-kernel/linux/$ make bcm2709_defconfig</span><br></pre></td></tr></table></figure>

<p>执行<code>make bcm2709_defconfig</code>的时候可以看到，如下图所示，打了实时补丁的内核，在<code>Preemption Model</code>中，多了一个选项<code>Fully Preemptible Kernel (RT)</code>，需要选中这个选项。</p>
<img src="/images/embedded-linux-real-time/menuconfig.png" width="713" height="415" align="center">

<h4 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h4><p>使用以下命令，编译内核/模块/dtb，并进行相应目录的安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/raspberrypi-kernel/linux$ make -j4 zImage</span><br><span class="line">~/raspberrypi-kernel/linux$ make -j4 modules</span><br><span class="line">~/raspberrypi-kernel/linux$ make -j4 dtbs</span><br><span class="line">~/raspberrypi-kernel/linux$ make -j4 modules_install</span><br><span class="line">~/raspberrypi-kernel/linux$ make -j4 dtbs_install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中，<code>-j4</code>是想利用编译机的多个核心，进行多线程的编译，这样编译起来比较快</p>
</blockquote>
<p>编译完成后，需要进行相应格式内核镜像生成命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/raspberrypi-kernel/linux$ mkdir $INSTALL_MOD_PATH/boot</span><br><span class="line">~/raspberrypi-kernel/linux$ ./scripts/mkknlimg ./arch/arm/boot/zImage $INSTALL_MOD_PATH/boot/$KERNEL.img</span><br></pre></td></tr></table></figure>

<h4 id="新内核安装"><a href="#新内核安装" class="headerlink" title="新内核安装"></a>新内核安装</h4><p>首先，将新内核相关文件传输到树莓派上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/raspberrypi-kernel/linux$ cd $INSTALL_MOD_PATH</span><br><span class="line">~/raspberrypi-kernel/rt-kernel$ tar czf ../rt-kernel.tgz *</span><br><span class="line">~/raspberrypi-kernel/rt-kernel$ cd ..</span><br><span class="line">~/raspberrypi-kernel$ scp rt-kernel.tgz pi@&lt;ipaddress&gt;:/tmp</span><br></pre></td></tr></table></figure>

<p>然后进行<code>Kernel Image, Modules &amp; Device Tree Overlays</code>的安装，在树莓派上执行以下命令：</p>
<blockquote>
<p>注意，在安装之前，要测试以下原内核的实时性能，测试方法下文中有介绍</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~$ cd /tmp</span><br><span class="line">/tmp$ tar xzf rt-kernel.tgz</span><br><span class="line">/tmp$ cd boot</span><br><span class="line">/tmp/boot$ sudo cp -rd * /boot/</span><br><span class="line">/tmp/boot$ cd ../lib</span><br><span class="line">/tmp/lib$ sudo cp -dr * /lib/</span><br><span class="line">/tmp/lib$ cd ../overlays</span><br><span class="line">/tmp/overlays$ sudo cp -d * /boot/overlays</span><br><span class="line">/tmp/overlays$ cd ..</span><br><span class="line">/tmp$ sudo cp -d bcm* /boot/</span><br></pre></td></tr></table></figure>

<p>并且需要修改<code>/boot/config.txt</code>中的信息，添加被引导的kernel版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel=vmlinuz-4.14.91-rt49-v7+</span><br></pre></td></tr></table></figure>

<p>这个版本号不能弄错，可以到<code>linux</code>源码根目录下的<code>Makefile</code>文件和<code>localversion-rt</code>文件分别查看<code>kernel</code>和<code>rt</code>对应的版本号。</p>
<h4 id="实时性能测试"><a href="#实时性能测试" class="headerlink" title="实时性能测试"></a>实时性能测试</h4><p>可以通过工具<code>cyclictest</code>工具来测试Linux实时性能。该工具的使用方法已经安装方法这里不做过多介绍。<br>使用以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cyclictest -p 90 - m -c 0 -i 200 -n -h 100 -l 1000000</span><br></pre></td></tr></table></figure>

<p>分别测试打实时补丁前后Linux实时性能如下图:<br><img src="/images/embedded-linux-real-time/kernel-latency-test.png" width="460" height="123" align="center"> <img src="/images/embedded-linux-real-time/kernel-latency-test-rt.png" width="460" height="123" align="center"></p>
<p>重点关注<code>Max Latencies</code>这一项，单位为微秒。由上图可知，kernel打上实时补丁后，实时性能有一定的提升。</p>


<!--<a href="http://www.howar.cn/2020/03/15/embedded-linux-real-time/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=&web_id=" language="JavaScript"></script>script>
</div>






</body>
</html>