<html>
<head><meta name="generator" content="Hexo 3.9.0">
	
	<title>linux进程、线程和调度(一)</title>
	<meta name="keywords" content="howar.cn">

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css">
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3">
    
    

</head>

<body>


<h2 class="title">linux进程、线程和调度(一)</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2018年7月19日


    <a class="article-category-link" href="/categories/Linux/">Linux</a>



 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux进程生命周期"><span class="toc-text">Linux进程生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是进程"><span class="toc-text">什么是进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程被如何管理"><span class="toc-text">进程被如何管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程生命周期"><span class="toc-text">进程生命周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#僵尸进程"><span class="toc-text">僵尸进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本概念"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#问题及危害"><span class="toc-text">问题及危害</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何杀死僵尸进程"><span class="toc-text">如何杀死僵尸进程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#停止状态与作业控制"><span class="toc-text">停止状态与作业控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深睡眠和浅睡眠"><span class="toc-text">深睡眠和浅睡眠</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初见fork"><span class="toc-text">初见fork</span></a></li></ol>
<h2 id="Linux进程生命周期"><a href="#Linux进程生命周期" class="headerlink" title="Linux进程生命周期"></a>Linux进程生命周期</h2><h4 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h4><p>进程是资源分配的单位，每个进程都有进程控制块(PCB)。</p>
<p>进程用task_strcut描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">task_struct</span><br><span class="line">&#123;</span><br><span class="line">    pid</span><br><span class="line">    ...</span><br><span class="line">    *mm</span><br><span class="line">    *fs</span><br><span class="line">    *files</span><br><span class="line">    *signal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码块展示了task_struct中描述的关于进程的比较重要的资源，如：进程号、内存资源、文件系统资源、文件资源、信号资源等。</p>
<p>其中，Linux中的进程号pid是有限的，可以通过<code>cat /proc/sys/kernel/pid_max</code>来查看当前系统所允许的最大进程个数。</p>
<p>一个有趣的实验：通过Fork炸弹，可以使系统挂掉。即运行<code>:(){:|:&amp;};:</code></p>
<h4 id="进程被如何管理"><a href="#进程被如何管理" class="headerlink" title="进程被如何管理"></a>进程被如何管理</h4><p>上节所示，进程用task_struct描述，而task_struct在linux中被多种数据结构描述：链表、树、哈希。用以满足不同的应用场景。</p>
<p>如果想表里所有进程，则使用链表；如果想知道进程间关系，则使用树；如果想通过pid快速检索一个进程，则使用哈希。</p>
<h4 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h4><p>用一张图总括linux中任务的生命周期：<br><br><img src="https://github.com/howar-luo/image_repo/blob/master/task_life.png?raw=true" alt="进程生命周期"><br><br>从上图可以看出，任务总共有六个状态。</p>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p>
<p>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>
<h4 id="问题及危害"><a href="#问题及危害" class="headerlink" title="问题及危害"></a>问题及危害</h4><p>在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait/waitpid来取时才释放。但这样就导致了问题，如果进程不调用wait/waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</p>
<h4 id="如何杀死僵尸进程"><a href="#如何杀死僵尸进程" class="headerlink" title="如何杀死僵尸进程"></a>如何杀死僵尸进程</h4><p>用kill是杀不死僵尸进程的。<br>杀死僵尸进程的方法有二：</p>
<ul>
<li>重启系统</li>
<li>杀掉该僵尸进程的父进程</li>
</ul>
<h2 id="停止状态与作业控制"><a href="#停止状态与作业控制" class="headerlink" title="停止状态与作业控制"></a>停止状态与作业控制</h2><p>停止态及任务停止工作，暂停了，且不占用cpu。</p>
<p>当收到STOP信号后，任务进入停止态，比如收到了<code>ctrl+z</code>，或者被<code>gdb attach</code>了。</p>
<p>其中<code>ctrl+z</code>属于作业控制。</p>
<h2 id="深睡眠和浅睡眠"><a href="#深睡眠和浅睡眠" class="headerlink" title="深睡眠和浅睡眠"></a>深睡眠和浅睡眠</h2><p>浅睡眠：可以被资源唤醒，也可以被信号唤醒。</p>
<p>深睡眠：只能被资源唤醒。</p>
<p>为何有了浅睡眠还要搞个深睡眠？考虑以下场景：</p>
<blockquote>
<p>如果执行到某个代码段，该代码段还在硬盘中，未被拷贝到内存中，则会产生一个pagefault，用以将该代码段读到内存中，接下来，linux会将该等待进程置位深度睡眠态。如果此时为浅度睡眠，则会相应signal，如果该signal的处理函数也未被读到内存，则又发生pagefault……这种情况处理起来太复杂了</p>
</blockquote>
<h2 id="初见fork"><a href="#初见fork" class="headerlink" title="初见fork"></a>初见fork</h2><p>首先看一段程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    fork();</span><br><span class="line">    printf(&quot;hello\r\n&quot;);</span><br><span class="line">    fork();</span><br><span class="line">    printf(&quot;hello\r\n&quot;);</span><br><span class="line">    while(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序会打印几个<code>hello</code>？答案是6个。</p>
<p>fork所执行的效果，既是一个进程进去，两个进程出来。</p>


<!--<a href="http://www.howar.cn/2018/07/19/linux-process-1/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=&web_id=" language="JavaScript"></script>script>
</div>






</body>
</html>